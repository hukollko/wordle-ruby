
# frozen_string_literal: true

require "open3"

# Создаем потокобезопасную очередь для каждого слова из словаря.
queue = Queue.new
File.foreach("5lenwords_russian_base.txt", chomp: true) { |word| queue << word }

# Создаем хэш, значением по умолчанию для любого нового ключа является 0.
# Мы будем использовать это, чтобы отслеживать, сколько попыток потребовалось, чтобы успешно дойти до финального слова.
results = Hash.new { 0 }

# Создаем список рабочих потоков, которые будут извлекать слова из словаря,
# пока все они не будут исчерпаны.
workers =
  8.times.map do
    Thread.new do
      until queue.empty?
        word = queue.shift
        guesses = 0

        # Открываем новый ruby-процесс, выполняющий файл wordle.rb. Внутри
        # блока вы можете писать в STDIN и читать из STDOUT IO объектов
        # для взаимодействия с дочерним процессом.
        Open3.popen2("ruby wordle.rb") do |stdin, stdout, waiter|
          # Протокол немного расплывчат, но в основном, если вы доходите до
          # финального слова, он выводит "Загаданное слово:", поэтому мы можем
          # использовать это как условие цикла.
          until (read = stdout.read(3)) == "Загаданное"
            guesses += 1

            # Читаем остаток предположения, а затем пропускаем приглашение в
            # STDOUT пайпе.
            guess = "#{read}#{stdout.read(2)}"
            stdout.read(10)

            # Создаем ввод, необходимый для того, чтобы сообщить дочернему
            # процессу, какие плитки стали какими цветами. Это аналогично
            # вводу предполагаемого слова в текстовое поле.
            chars =
              guess.each_char.map.with_index do |char, index|
                if word[index] == char
                  "p"
                elsif word.include?(char)
                  ";"
                else
                  "_"
                end
              end

            # Записываем ввод в STDIN и отправляем его по пайпу, чтобы дочерний
            # процесс разблокировал свое чтение.
            stdin.write("#{chars.join}\n")
            stdin.flush
          end

          # Как только мы сюда доберемся, он начнет печатать "Загаданное слово:",
          # поэтому читаем остаток и затем проверяем, что он выбрал
          # правильное слово.
          stdout.read(10)
          raise if stdout.read(5) != word
        end

        results[guesses] += 1
      end
    end
  end

# Присоединяем каждый рабочий поток обратно к основному потоку, чтобы
# убедиться, что мы дождемся завершения всего.
workers.map(&:join)

# Выводим окончательные результаты, которые показывают, сколько попыток
# потребовалось, чтобы добраться до каждого слова. В идеале все числа
# должны быть 5 или меньше (количество фактических попыток, которые вы получаете).
p results.sort.to_h

# Получаем оценку результатов, которая составляет 10 баллов за каждое
# слово, угаданное за 3 попытки, 5 баллов за каждое слово, угаданное за
# 6 попыток, и 0 баллов за все остальные слова.
score =
  (results[1] + results[2] + results[3]) * 10 +
    (results[4] + results[5] + results[6]) * 5

p score